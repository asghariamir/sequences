<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequences Convergence Explorer | Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    
    <style>
        :root {
            --primary: #0f766e;
            --primary-light: #10b981;
            --background: #f7faf9;
            --interactive: #e6fffb;
            --text-primary: #212121;
            --text-muted: #4b5563;
            --accent-amber: #f59e0b;
            --accent-red: #c62828;
            --success: #10b981;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        /* Mathswell Logo - Centered at Top */
        .mathswell-nav {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        
        .mw-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            color: var(--primary);
            background: white;
            padding: 0.5rem 1rem;
            border-radius: 999px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-weight: 700;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .mw-link:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(15,118,110,0.2);
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 4rem 1rem 2rem;
        }
        
        .tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 3rem;
            background: white;
            padding: 0.75rem;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            justify-content: center;
        }
        
        .tab-btn {
            padding: 1rem 2rem;
            background: transparent;
            color: var(--text-muted);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .tab-btn:hover {
            background: var(--interactive);
        }
        
        .tab-btn.active {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15,118,110,0.3);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .hero {
            text-align: center;
            padding: 3rem 1rem;
            background: linear-gradient(135deg, white 0%, var(--interactive) 100%);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }
        
        .hero h1 {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }
        
        .hero p {
            font-size: 1.2rem;
            color: var(--text-muted);
            max-width: 600px;
            margin: 0 auto;
        }
        
        .concept-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .concept-card {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .concept-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        }
        
        .concept-card h3 {
            color: var(--primary);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .concept-card .icon {
            font-size: 1.5rem;
        }
        
        .demo-container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        
        .demo-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .slider-group {
            flex: 1;
            min-width: 250px;
        }
        
        .slider-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary);
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--interactive);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(15,118,110,0.4);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }
        
        .value-display {
            display: inline-block;
            background: var(--interactive);
            padding: 0.25rem 0.75rem;
            border-radius: 6px;
            font-family: 'Monaco', monospace;
            margin-left: 0.5rem;
            font-weight: 600;
            color: var(--primary);
        }
        
        .view-panel {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            border: 1px solid rgba(15,118,110,0.1);
            margin-bottom: 1.5rem;
        }
        
        .view-panel h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        
        canvas {
            border: 2px solid var(--primary);
            border-radius: 6px;
            width: 100%;
            display: block;
            background: white;
        }
        
        .preset-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }
        
        .preset-pill {
            padding: 0.4rem 1rem;
            border-radius: 999px;
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }
        
        .preset-pill:hover, .preset-pill.active {
            background: var(--interactive);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15,118,110,0.2);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .info-box {
            background: var(--interactive);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'Monaco', monospace;
        }
        
        .info-box h4 {
            color: var(--primary);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
        }
        
        .info-box .value {
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .floating-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 200px;
            font-size: 0.85rem;
        }
        
        .floating-info div {
            margin-bottom: 0.5rem;
        }
        
        .floating-info div:last-child {
            margin-bottom: 0;
        }
        
        .floating-info .label {
            color: var(--primary);
            font-weight: 600;
        }
        
        .nav-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }
        
        .nav-btn {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .nav-btn:hover {
            background: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15,118,110,0.3);
        }
        
        .insights {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-top: 2rem;
        }
        
        .insights h3 {
            color: var(--primary);
            margin-bottom: 1rem;
        }
        
        .insight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }
        
        .insight-item {
            padding: 1rem;
            background: var(--background);
            border-radius: 8px;
        }
        
        .visualization-panel {
            background: white;
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
            position: relative;
        }
        
        .mode-toggle {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            background: white;
            padding: 0.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .mode-btn {
            padding: 0.5rem 1.5rem;
            background: transparent;
            color: var(--text-muted);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .mode-btn:hover {
            background: var(--interactive);
        }
        
        .mode-btn.active {
            background: var(--interactive);
            color: var(--primary);
            border-color: var(--primary);
        }
        
        .play-btn {
            background: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            margin-left: 1rem;
        }
        
        .play-btn:hover {
            background: var(--primary-light);
        }
        
        .challenge-section {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
            margin-bottom: 1.5rem;
        }
        
        .challenge-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--primary);
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 1rem;
        }
        
        .feedback-box {
            background: var(--interactive);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            display: none;
        }
        
        .feedback-box.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .feedback-box.success {
            background: #d4edda;
            border-left: 4px solid var(--success);
        }
        
        .feedback-box.hint {
            background: #fff3cd;
            border-left: 4px solid var(--accent-amber);
        }
        
        .feedback-box.error {
            background: #f8d7da;
            border-left: 4px solid var(--accent-red);
        }
        
        .math-display {
            font-size: 1.1rem;
            margin: 1rem 0;
            text-align: center;
        }
        
        .control-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }
        
        .scramble-container {
            margin: 1.5rem 0;
        }
        
        .scramble-cards {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }
        
        .scramble-card {
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 1rem;
            cursor: move;
            transition: all 0.3s ease;
        }
        
        .scramble-card:hover {
            background: var(--interactive);
        }
        
        .scramble-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 1.8rem;
            }
            
            .concept-cards {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                gap: 0.5rem;
                padding: 0.5rem;
            }
            
            .tab-btn {
                padding: 0.75rem 1rem;
                font-size: 0.9rem;
            }
            
            .floating-info {
                position: static;
                margin-top: 1rem;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- Mathswell Logo Badge - Centered -->
    <div class="mathswell-nav">
        <a href="/" class="mw-link">
            <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="24" height="24">
            <span>MATHSWELL</span>
        </a>
    </div>
    
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="intro">Introduction</button>
            <button class="tab-btn" data-tab="explorer">Explorer</button>
            <button class="tab-btn" data-tab="challenge">Challenge</button>
        </div>
        
        <!-- Introduction Tab -->
        <div id="intro" class="tab-content active">
            <div class="hero">
                <h1>Understanding Sequence Convergence</h1>
                <p>Discover how mathematicians capture the idea of "getting closer" in a precise definition</p>
            </div>
            
            <div class="concept-cards">
                <div class="concept-card">
                    <h3><span class="icon">📊</span> What is a Sequence?</h3>
                    <p>An infinite list of numbers with a precise rule that determines each term uniquely.</p>
                    <div class="math-display" id="seq-example-1"></div>
                    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                        Each natural number n maps to exactly one real number aₙ
                    </p>
                </div>
                
                <div class="concept-card">
                    <h3><span class="icon">🎯</span> Convergence Intuition</h3>
                    <p>A sequence converges when its terms get arbitrarily close to a limit L as n approaches infinity.</p>
                    <div class="math-display" id="conv-example"></div>
                    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                        The terms cluster around the target value
                    </p>
                </div>
                
                <div class="concept-card">
                    <h3><span class="icon">🔬</span> The ε-N Definition</h3>
                    <p>For any ε > 0, we can find N where all terms after N stay within ε of L.</p>
                    <div class="math-display" id="epsilon-def"></div>
                    <p style="margin-top: 0.5rem; font-size: 0.9rem; color: var(--text-muted);">
                        This captures "getting closer" mathematically
                    </p>
                </div>
            </div>
            
            <div class="demo-container">
                <h3 style="color: var(--primary); margin-bottom: 1rem;">Interactive Demo: See Convergence in Action</h3>
                <div class="demo-controls">
                    <div class="slider-group">
                        <label>Epsilon (ε): <span class="value-display" id="demo-epsilon-value">0.300</span></label>
                        <input type="range" class="slider" id="demo-epsilon" min="0.01" max="1" step="0.01" value="0.3">
                    </div>
                    <div class="slider-group">
                        <label>View Terms: <span class="value-display" id="demo-terms-value">30</span></label>
                        <input type="range" class="slider" id="demo-terms" min="10" max="50" step="5" value="30">
                    </div>
                </div>
                
                <div class="view-panel">
                    <h4>Coordinate Plot (n, aₙ)</h4>
                    <canvas id="demo-canvas" height="250"></canvas>
                </div>
                
                <div class="view-panel">
                    <h4>Number Line Strip</h4>
                    <canvas id="demo-strip-canvas" height="120"></canvas>
                </div>
                
                <div class="info-grid">
                    <div class="info-box">
                        <h4>Required N</h4>
                        <div class="value" id="demo-n-value">4</div>
                    </div>
                    <div class="info-box">
                        <h4>Terms within ε</h4>
                        <div class="value" id="demo-within">All after N</div>
                    </div>
                    <div class="info-box">
                        <h4>Sequence</h4>
                        <div class="value">aₙ = 1/n → 0</div>
                    </div>
                </div>
            </div>
            
            <div class="insights">
                <h3>Two Ways to Think About Convergence</h3>
                <div class="insight-grid">
                    <div class="insight-item">
                        <h4 style="color: var(--primary);">🌊 Intuitive View</h4>
                        <p>Terms get closer and closer to the limit, like waves approaching the shore. We can visualize this as dots clustering around a target value.</p>
                    </div>
                    <div class="insight-item">
                        <h4 style="color: var(--primary);">📐 Formal View</h4>
                        <p>We can make terms as close as we want (within ε) by going far enough (past N). This gives us mathematical precision.</p>
                    </div>
                </div>
            </div>
            
            <div class="nav-buttons">
                <button class="nav-btn" onclick="switchTab('explorer')">Explore Sequences →</button>
                <button class="nav-btn" onclick="switchTab('challenge')">Try Challenges →</button>
            </div>
        </div>
        
        <!-- Explorer Tab -->
        <div id="explorer" class="tab-content">
            <h2 style="color: var(--primary); margin-bottom: 1.5rem; text-align: center;">Sequence Explorer</h2>
            
            <div class="mode-toggle">
                <button class="mode-btn active" onclick="switchMode('convergent')">Convergent Sequences</button>
                <button class="mode-btn" onclick="switchMode('divergent')">Divergent Sequences</button>
            </div>
            
            <!-- Convergent Mode -->
            <div id="convergent-mode">
                <div class="preset-pills">
                    <button class="preset-pill active" data-seq="1/n" data-limit="0">Classic: 1/n → 0</button>
                    <button class="preset-pill" data-seq="Math.pow(0.5, n)" data-limit="0">Geometric: (1/2)ⁿ → 0</button>
                    <button class="preset-pill" data-seq="Math.pow(-1, n)/n" data-limit="0">Oscillating: (-1)ⁿ/n → 0</button>
                    <button class="preset-pill" data-seq="n/(n+1)" data-limit="1">Rational: n/(n+1) → 1</button>
                    <button class="preset-pill" data-seq="(Math.pow(-1, n) + n)/(n)" data-limit="1">Mixed: ((-1)ⁿ + n)/n → 1</button>
                    <button class="preset-pill" data-seq="(2*n + 3)/(n + 1)" data-limit="2">Linear: (2n+3)/(n+1) → 2</button>
                </div>
                
                <!-- Epsilon-N Controller ABOVE the plots -->
                <div class="demo-container">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">Epsilon-N Controller</h4>
                    <div class="demo-controls">
                        <div class="slider-group">
                            <label>Epsilon (ε): <span class="value-display" id="explorer-epsilon-value">0.100</span></label>
                            <input type="range" class="slider" id="explorer-epsilon" min="0.001" max="1" step="0.001" value="0.1">
                        </div>
                        <div class="slider-group">
                            <label>View Terms: <span class="value-display" id="explorer-terms-value">30</span></label>
                            <input type="range" class="slider" id="explorer-terms" min="10" max="100" step="5" value="30">
                        </div>
                    </div>
                </div>
                
                <div class="visualization-panel">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">
                        Coordinate Plot (n, aₙ)
                        <button class="play-btn" onclick="animateSequence()">▶ Animate</button>
                    </h4>
                    <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1rem;">
                        Watch how terms enter and stay within the epsilon band around the limit
                    </p>
                    <canvas id="coord-canvas" height="300"></canvas>
                    <div class="floating-info" id="coord-info">
                        <div><span class="label">Sequence:</span> <span id="float-seq">1/n</span></div>
                        <div><span class="label">Status:</span> <span id="float-status">Converges to 0</span></div>
                        <div><span class="label">Required N:</span> <span id="float-n">11</span></div>
                        <div><span class="label">Within ε:</span> <span id="float-within">All after N</span></div>
                    </div>
                </div>
                
                <div class="visualization-panel">
                    <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Number Line View (Convergence Strip)</h4>
                    <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1rem;">
                        Terms shown as vertical lines. Watch them cluster within the epsilon band (shaded region)
                    </p>
                    <canvas id="strip-canvas" height="150"></canvas>
                </div>
            </div>
            
            <!-- Divergent Mode -->
            <div id="divergent-mode" style="display: none;">
                <div class="preset-pills">
                    <button class="preset-pill active" data-seq="Math.pow(-1, n)">Oscillating: (-1)ⁿ</button>
                    <button class="preset-pill" data-seq="Math.sin(n)">Periodic: sin(n)</button>
                    <button class="preset-pill" data-seq="n">Unbounded: n</button>
                    <button class="preset-pill" data-seq="Math.pow(-1, n) * n">Growing: (-1)ⁿ·n</button>
                    <button class="preset-pill" data-seq="Math.log(n)">Logarithmic: ln(n)</button>
                </div>
                
                <div class="demo-container">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">Test a Proposed Limit</h4>
                    <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1rem;">
                        For any proposed limit L, there exists an epsilon such that infinitely many terms lie outside L ± ε
                    </p>
                    <div class="demo-controls">
                        <div class="slider-group">
                            <label>Proposed Limit L: <span class="value-display" id="test-limit-value">0.0</span></label>
                            <input type="range" class="slider" id="test-limit" min="-2" max="2" step="0.1" value="0">
                        </div>
                        <div class="slider-group">
                            <label>Test Epsilon (ε): <span class="value-display" id="div-epsilon-value">0.500</span></label>
                            <input type="range" class="slider" id="div-epsilon" min="0.1" max="2" step="0.05" value="0.5">
                        </div>
                    </div>
                </div>
                
                <div class="visualization-panel">
                    <h4 style="color: var(--primary); margin-bottom: 1rem;">
                        Why These Sequences Diverge
                        <button class="play-btn" onclick="animateDivergence()">▶ Animate</button>
                    </h4>
                    <p style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 1rem;">
                        <strong>Key insight:</strong> Terms continue to escape the ε-band no matter how large N is chosen
                    </p>
                    <canvas id="divergent-canvas" height="350"></canvas>
                    <div class="floating-info" id="div-info">
                        <div><span class="label">Sequence:</span> <span id="div-seq">(-1)ⁿ</span></div>
                        <div><span class="label">Test L:</span> <span id="div-limit">0</span></div>
                        <div><span class="label">Status:</span> <span id="div-escape" style="color: var(--accent-red); font-weight: bold;">Always has escaping terms</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Challenge Tab -->
        <div id="challenge" class="tab-content">
            <h2 style="color: var(--primary); margin-bottom: 2rem; text-align: center;">Convergence Challenge</h2>
            
            <div class="preset-pills">
                <button class="preset-pill active" onclick="loadChallenge('detective')">Convergence Detective</button>
                <button class="preset-pill" onclick="loadChallenge('epsilon')">Epsilon-N Mastery</button>
                <button class="preset-pill" onclick="loadChallenge('proof')">Proof by Cards</button>
            </div>
            
            <div class="challenge-section">
                <div id="challenge-question" style="background: var(--interactive); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                    <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Question 1: Convergence Detective</h4>
                    <p>Consider the sequence:</p>
                    <div class="math-display" id="challenge-seq"></div>
                    <p>Does this sequence converge? If yes, what is the limit?</p>
                </div>
                
                <div id="standard-challenge">
                    <input type="text" class="challenge-input" id="challenge-answer" placeholder="Enter your answer (e.g., 'converges to 0' or 'diverges')">
                    
                    <div class="control-buttons">
                        <button class="nav-btn" onclick="quickCheck()">Quick Check</button>
                        <button class="nav-btn" onclick="getHint()">Get Hint</button>
                        <button class="nav-btn" onclick="challengeAI()">Challenge AI</button>
                    </div>
                    
                    <div style="margin-top: 1rem; padding: 0.75rem; background: var(--background); border-radius: 6px; font-size: 0.85rem; color: var(--text-muted); text-align: center;">
                        <strong>AI Feedback Notice:</strong> The "Challenge AI" button uses artificial intelligence to provide personalized feedback. 
                        AI responses are generated to help your learning but may occasionally contain errors. 
                        Always verify mathematical concepts with your teacher or textbook.
                    </div>
                </div>
                
                <div id="proof-challenge" style="display: none;">
                    <div class="scramble-container">
                        <p style="margin-bottom: 1rem;">Arrange these steps in the correct order to complete the proof:</p>
                        <div class="scramble-cards" id="scramble-cards"></div>
                        <div class="control-buttons">
                            <button class="nav-btn" onclick="checkCardOrder()">Check Order</button>
                            <button class="nav-btn" onclick="shuffleCards()">Shuffle Again</button>
                            <button class="nav-btn" onclick="showCorrectOrder()">Show Solution</button>
                        </div>
                    </div>
                </div>
                
                <div class="feedback-box" id="feedback"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentMode = 'convergent';
        let currentSequence = '1/n';
        let currentLimit = 0;
        let divergentSequence = 'Math.pow(-1, n)';
        let animationId = null;
        let animationFrame = 0;
        let challengeMode = 'detective';
        let currentChallenge = null;
        let attempts = 0;
        let draggedCard = null;
        
        // Challenge definitions
        const challenges = {
            detective: [
                { seq: '\\frac{2n+1}{n}', answer: 'converges to 2', hint: 'Divide numerator and denominator by n', acceptableAnswers: ['2', 'converges to 2', 'convergesto2', 'convergesto 2', 'converge to 2', '→2', '->2', 'limit is 2', 'limit 2', 'l=2'] },
                { seq: '\\frac{n^2}{n^2+1}', answer: 'converges to 1', hint: 'What happens when n is very large?', acceptableAnswers: ['1', 'converges to 1', 'convergesto1', 'convergesto 1', 'converge to 1', '→1', '->1', 'limit is 1', 'limit 1', 'l=1'] },
                { seq: '\\sin(n)', answer: 'diverges', hint: 'Think about the periodic nature of sine', acceptableAnswers: ['diverges', 'diverge', 'divergent', 'no limit', 'doesnt converge', 'does not converge', 'oscillates'] },
                { seq: '(-1)^n', answer: 'diverges', hint: 'The sequence alternates between 1 and -1', acceptableAnswers: ['diverges', 'diverge', 'divergent', 'no limit', 'doesnt converge', 'does not converge', 'oscillates', 'alternates'] },
                { seq: '\\frac{3n^2 + 2}{n^2 - 1}', answer: 'converges to 3', hint: 'Compare the leading coefficients', acceptableAnswers: ['3', 'converges to 3', 'convergesto3', 'convergesto 3', '→3', '->3', 'limit is 3', 'limit 3', 'l=3'] }
            ],
            epsilon: [
                { seq: '\\frac{1}{n}', limit: 0, epsilon: 0.01, answer: 101, hint: 'Solve 1/n < 0.01', acceptableAnswers: [101, '101'] },
                { seq: '\\frac{1}{2^n}', limit: 0, epsilon: 0.001, answer: 11, hint: 'Use logarithms', acceptableAnswers: [11, '11'] },
                { seq: '\\frac{2n}{n+1}', limit: 2, epsilon: 0.1, answer: 10, hint: 'Solve |2n/(n+1) - 2| < 0.1', acceptableAnswers: [10, '10'] }
            ],
            proof: [
                {
                    seq: '\\frac{1}{n}',
                    limit: 0,
                    type: 'convergence',
                    steps: [
                        'Given ε > 0, we need to find N such that |aₙ - L| < ε for all n > N',
                        'We have |1/n - 0| = 1/n',
                        'We want 1/n < ε',
                        'This gives n > 1/ε',
                        'Choose N = ⌈1/ε⌉',
                        'Then for all n > N, we have 1/n < 1/N ≤ ε',
                        'Therefore, the sequence converges to 0'
                    ]
                },
                {
                    seq: '(-1)^n',
                    type: 'divergence',
                    steps: [
                        'Assume the sequence converges to some limit L',
                        'Then for ε = 0.5, there exists N such that |aₙ - L| < 0.5 for all n > N',
                        'For even n > N: |1 - L| < 0.5, so 0.5 < L < 1.5',
                        'For odd n > N: |-1 - L| < 0.5, so -1.5 < L < -0.5',
                        'These two conditions are contradictory',
                        'Therefore, the sequence diverges'
                    ]
                }
            ]
        };
        
        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabName) {
                    btn.classList.add('active');
                }
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'intro') {
                setTimeout(initDemoCanvas, 100);
            } else if (tabName === 'explorer') {
                setTimeout(() => {
                    if (currentMode === 'convergent') {
                        initConvergentCanvases();
                    } else {
                        initDivergentCanvas();
                    }
                }, 100);
            }
        }
        
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
        
        // Mode switching
        function switchMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            if (mode === 'convergent') {
                document.getElementById('convergent-mode').style.display = 'block';
                document.getElementById('divergent-mode').style.display = 'none';
                setTimeout(initConvergentCanvases, 100);
            } else {
                document.getElementById('convergent-mode').style.display = 'none';
                document.getElementById('divergent-mode').style.display = 'block';
                setTimeout(initDivergentCanvas, 100);
            }
        }
        
        // Math rendering
        function renderMath() {
            if (document.getElementById('seq-example-1')) {
                katex.render("a_n = \\frac{1}{n}: 1, \\frac{1}{2}, \\frac{1}{3}, ...", 
                    document.getElementById('seq-example-1'), {displayMode: true});
            }
            
            if (document.getElementById('conv-example')) {
                katex.render("\\lim_{n \\to \\infty} \\frac{1}{n} = 0", 
                    document.getElementById('conv-example'), {displayMode: true});
            }
            
            if (document.getElementById('epsilon-def')) {
                katex.render("|a_n - L| < \\varepsilon \\text{ for all } n > N", 
                    document.getElementById('epsilon-def'), {displayMode: true});
            }
            
            updateChallengeSequence();
        }
        
        // Sequence evaluation
        function evaluateSequence(formula, n) {
            try {
                const cleanFormula = formula.trim().replace(/;+$/, '');
                const evalFunc = new Function('n', 'Math', `return ${cleanFormula};`);
                return evalFunc(n, Math);
            } catch (e) {
                return NaN;
            }
        }
        
        // Demo canvas functions
        function initDemoCanvas() {
            drawDemoCoordinate();
            drawDemoStrip();
        }
        
        function drawDemoCoordinate() {
            const canvas = document.getElementById('demo-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 250;
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const epsilon = parseFloat(document.getElementById('demo-epsilon').value);
            const maxTerms = parseInt(document.getElementById('demo-terms').value);
            document.getElementById('demo-epsilon-value').textContent = epsilon.toFixed(3);
            document.getElementById('demo-terms-value').textContent = maxTerms;
            
            const N = Math.ceil(1 / epsilon);
            document.getElementById('demo-n-value').textContent = N;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(30, height - 30);
            ctx.lineTo(width - 10, height - 30);
            ctx.moveTo(30, height - 30);
            ctx.lineTo(30, 10);
            ctx.stroke();
            
            // Draw limit line at y=0
            ctx.strokeStyle = '#0f766e';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(30, height - 30);
            ctx.lineTo(width - 10, height - 30);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw epsilon band
            const epsilonPixels = epsilon * (height - 50);
            ctx.fillStyle = 'rgba(15, 118, 110, 0.1)';
            ctx.fillRect(30, height - 30 - epsilonPixels, width - 40, 2 * epsilonPixels);
            
            // Draw N line
            if (N <= maxTerms) {
                const nX = 30 + (N - 1) * ((width - 40) / maxTerms);
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(nX, height - 30);
                ctx.lineTo(nX, 10);
                ctx.stroke();
                
                ctx.fillStyle = '#f59e0b';
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText(`N=${N}`, nX - 15, 10);
            }
            
            // Draw points with sticks
            for (let n = 1; n <= maxTerms; n++) {
                const x = 30 + (n - 1) * ((width - 40) / maxTerms);
                const value = 1 / n;
                const y = height - 30 - value * (height - 50);
                
                // Draw stick
                ctx.strokeStyle = n >= N ? 'rgba(16, 185, 129, 0.5)' : 'rgba(198, 40, 40, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, height - 30);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Draw point
                ctx.fillStyle = n >= N ? '#10b981' : '#c62828';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Labels
            ctx.fillStyle = '#212121';
            ctx.font = '10px sans-serif';
            ctx.fillText('n', width - 10, height - 15);
            ctx.fillText('aₙ', 15, 10);
        }
        
        function drawDemoStrip() {
            const canvas = document.getElementById('demo-strip-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 120;
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const epsilon = parseFloat(document.getElementById('demo-epsilon').value);
            const maxTerms = parseInt(document.getElementById('demo-terms').value);
            const N = Math.ceil(1 / epsilon);
            
            // Draw number line horizontally
            const centerY = height / 2;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, centerY);
            ctx.lineTo(width - 20, centerY);
            ctx.stroke();
            
            // Scale for number line (0 to 1 for 1/n sequence)
            const minVal = -0.2;
            const maxVal = 1.2;
            const scale = (width - 40) / (maxVal - minVal);
            
            // Draw scale marks
            for (let val = 0; val <= 1; val += 0.5) {
                const x = 20 + (val - minVal) * scale;
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, centerY - 5);
                ctx.lineTo(x, centerY + 5);
                ctx.stroke();
                
                ctx.fillStyle = '#333';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(val.toString(), x, centerY + 20);
            }
            
            // Draw limit point at L = 0
            const limitX = 20 + (0 - minVal) * scale;
            ctx.fillStyle = '#0f766e';
            ctx.beginPath();
            ctx.arc(limitX, centerY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw epsilon band (shaded region)
            const epsilonPixels = epsilon * scale;
            ctx.fillStyle = 'rgba(15, 118, 110, 0.15)';
            ctx.fillRect(limitX - epsilonPixels, 10, 2 * epsilonPixels, height - 20);
            
            // Draw epsilon boundaries
            ctx.strokeStyle = 'rgba(15, 118, 110, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(limitX - epsilonPixels, 10);
            ctx.lineTo(limitX - epsilonPixels, height - 10);
            ctx.moveTo(limitX + epsilonPixels, 10);
            ctx.lineTo(limitX + epsilonPixels, height - 10);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw sequence terms as vertical sticks
            for (let n = 1; n <= Math.min(maxTerms, 30); n++) {
                const value = 1 / n;
                const x = 20 + (value - minVal) * scale;
                
                ctx.strokeStyle = n >= N ? '#10b981' : '#c62828';
                ctx.lineWidth = n === 1 ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(x, centerY - 20);
                ctx.lineTo(x, centerY + 20);
                ctx.stroke();
                
                // Label some key terms
                if (n <= 3 || n === N) {
                    ctx.fillStyle = '#666';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`n=${n}`, x, centerY - 25);
                }
            }
            
            // Labels
            ctx.fillStyle = '#0f766e';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('L = 0', limitX - 20, 10);
            
            // Epsilon label on the band
            ctx.fillStyle = '#0f766e';
            ctx.font = '10px sans-serif';
            ctx.fillText(`ε = ${epsilon.toFixed(3)}`, limitX + epsilonPixels + 5, centerY - 5);
        }
        
        // Convergent canvases
        function initConvergentCanvases() {
            drawCoordinatePlot();
            drawStripView();
            updateFloatingInfo();
        }
        
        function drawCoordinatePlot() {
            const canvas = document.getElementById('coord-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 300;
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const epsilon = parseFloat(document.getElementById('explorer-epsilon').value);
            const maxTerms = parseInt(document.getElementById('explorer-terms').value);
            
            // Calculate value range
            let minValue = Infinity, maxValue = -Infinity;
            for (let n = 1; n <= maxTerms; n++) {
                const value = evaluateSequence(currentSequence, n);
                if (!isNaN(value) && isFinite(value)) {
                    minValue = Math.min(minValue, value);
                    maxValue = Math.max(maxValue, value);
                }
            }
            
            const range = maxValue - minValue;
            const padding = range * 0.1 || 0.5;
            minValue -= padding;
            maxValue += padding;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(30, height - 30);
            ctx.lineTo(width - 10, height - 30);
            ctx.moveTo(30, height - 30);
            ctx.lineTo(30, 10);
            ctx.stroke();
            
            // Draw epsilon band and limit line
            if (currentLimit !== 'none') {
                const limitY = height - 30 - ((currentLimit - minValue) / (maxValue - minValue)) * (height - 60);
                
                ctx.strokeStyle = '#0f766e';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(30, limitY);
                ctx.lineTo(width - 10, limitY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                const epsilonPixels = (epsilon / (maxValue - minValue)) * (height - 60);
                ctx.fillStyle = 'rgba(15, 118, 110, 0.1)';
                ctx.fillRect(30, limitY - epsilonPixels, width - 40, 2 * epsilonPixels);
                
                ctx.fillStyle = '#0f766e';
                ctx.font = 'bold 10px sans-serif';
                ctx.fillText(`L=${currentLimit}`, width - 40, limitY - 5);
            }
            
            // Draw points with sticks
            let N = null;
            for (let n = 1; n <= maxTerms; n++) {
                const x = 30 + (n - 1) * ((width - 40) / maxTerms);
                const value = evaluateSequence(currentSequence, n);
                
                if (!isNaN(value) && isFinite(value)) {
                    const y = height - 30 - ((value - minValue) / (maxValue - minValue)) * (height - 60);
                    
                    let pointColor = '#c62828';
                    let stickColor = 'rgba(198, 40, 40, 0.5)';
                    if (currentLimit !== 'none') {
                        if (Math.abs(value - currentLimit) < epsilon) {
                            if (N === null) N = n;
                            pointColor = '#10b981';
                            stickColor = 'rgba(16, 185, 129, 0.5)';
                        }
                    }
                    
                    // Draw stick from x-axis
                    ctx.strokeStyle = stickColor;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, height - 30);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // Draw point
                    ctx.fillStyle = pointColor;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Draw N line
            if (N !== null && N <= maxTerms) {
                const nX = 30 + (N - 1) * ((width - 40) / maxTerms);
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(nX, height - 30);
                ctx.lineTo(nX, 10);
                ctx.stroke();
                
                ctx.fillStyle = '#f59e0b';
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText(`N=${N}`, nX - 15, 10);
            }
            
            // Y-axis labels
            ctx.fillStyle = '#666';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const yValue = minValue + (maxValue - minValue) * (i / 4);
                const y = height - 30 - (i / 4) * (height - 60);
                ctx.fillText(yValue.toFixed(2), 25, y + 3);
            }
            
            ctx.fillStyle = '#212121';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('n', width - 10, height - 15);
            ctx.textAlign = 'left';
            ctx.fillText('aₙ', 15, 10);
        }
        
        function drawStripView() {
            const canvas = document.getElementById('strip-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 150;
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const epsilon = parseFloat(document.getElementById('explorer-epsilon').value);
            const maxTerms = parseInt(document.getElementById('explorer-terms').value);
            
            if (currentLimit === 'none') return;
            
            // Calculate N and value range
            let N = null;
            let minVal = currentLimit - 2 * epsilon;
            let maxVal = currentLimit + 2 * epsilon;
            
            // Adjust range based on actual values
            for (let n = 1; n <= Math.min(maxTerms, 50); n++) {
                const value = evaluateSequence(currentSequence, n);
                if (!isNaN(value) && isFinite(value)) {
                    minVal = Math.min(minVal, value);
                    maxVal = Math.max(maxVal, value);
                    if (Math.abs(value - currentLimit) < epsilon && N === null) {
                        N = n;
                    }
                }
            }
            
            const range = maxVal - minVal;
            const padding = range * 0.1;
            minVal -= padding;
            maxVal += padding;
            const scale = (width - 40) / (maxVal - minVal);
            
            // Draw number line
            const centerY = height / 2;
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, centerY);
            ctx.lineTo(width - 20, centerY);
            ctx.stroke();
            
            // Draw limit point
            const limitX = 20 + (currentLimit - minVal) * scale;
            
            // Draw epsilon band (shaded region)
            const epsilonPixels = epsilon * scale;
            ctx.fillStyle = 'rgba(15, 118, 110, 0.15)';
            ctx.fillRect(limitX - epsilonPixels, 20, 2 * epsilonPixels, height - 40);
            
            // Draw epsilon boundaries
            ctx.strokeStyle = 'rgba(15, 118, 110, 0.6)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(limitX - epsilonPixels, 20);
            ctx.lineTo(limitX - epsilonPixels, height - 20);
            ctx.moveTo(limitX + epsilonPixels, 20);
            ctx.lineTo(limitX + epsilonPixels, height - 20);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw limit marker
            ctx.fillStyle = '#0f766e';
            ctx.beginPath();
            ctx.arc(limitX, centerY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw sequence terms as vertical sticks
            for (let n = 1; n <= Math.min(maxTerms, 50); n++) {
                const value = evaluateSequence(currentSequence, n);
                
                if (!isNaN(value) && isFinite(value)) {
                    const x = 20 + (value - minVal) * scale;
                    
                    const isWithinEpsilon = Math.abs(value - currentLimit) < epsilon;
                    ctx.strokeStyle = isWithinEpsilon ? '#10b981' : '#c62828';
                    ctx.lineWidth = n <= 5 ? 2 : 1;
                    
                    // Draw vertical stick
                    ctx.beginPath();
                    ctx.moveTo(x, centerY - 25);
                    ctx.lineTo(x, centerY + 25);
                    ctx.stroke();
                    
                    // Label first few terms
                    if (n <= 3) {
                        ctx.fillStyle = '#666';
                        ctx.font = '9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(`n=${n}`, x, centerY - 30);
                    }
                }
            }
            
            // N marker
            if (N !== null) {
                const value = evaluateSequence(currentSequence, N);
                if (!isNaN(value) && isFinite(value)) {
                    const nX = 20 + (value - minVal) * scale;
                    ctx.fillStyle = '#f59e0b';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`N=${N}`, nX, 15);
                }
            }
            
            // Labels
            ctx.fillStyle = '#0f766e';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`L = ${currentLimit}`, limitX, height - 5);
            
            // Epsilon label
            ctx.fillStyle = '#0f766e';
            ctx.font = '10px sans-serif';
            ctx.fillText(`ε = ${epsilon.toFixed(3)}`, limitX + epsilonPixels + 5, centerY);
        }
        
        function updateFloatingInfo() {
            const epsilon = parseFloat(document.getElementById('explorer-epsilon').value);
            document.getElementById('explorer-epsilon-value').textContent = epsilon.toFixed(3);
            document.getElementById('explorer-terms-value').textContent = document.getElementById('explorer-terms').value;
            
            let seqDisplay = currentSequence.replace('Math.pow(-1, n)', '(-1)ⁿ')
                                             .replace('Math.pow(0.5, n)', '(1/2)ⁿ')
                                             .replace('(2*n + 3)/(n + 1)', '(2n+3)/(n+1)');
            
            document.getElementById('float-seq').textContent = seqDisplay;
            document.getElementById('float-status').textContent = `Converges to ${currentLimit}`;
            
            // Calculate N
            let N = 'Calculate';
            for (let n = 1; n <= 1000; n++) {
                const value = evaluateSequence(currentSequence, n);
                if (!isNaN(value) && isFinite(value) && Math.abs(value - currentLimit) < epsilon) {
                    N = n;
                    break;
                }
            }
            document.getElementById('float-n').textContent = N;
            document.getElementById('float-within').textContent = N !== 'Calculate' ? 'All after N' : 'Calculating...';
        }
        
        // Divergent canvas
        function initDivergentCanvas() {
            drawDivergentPlot();
        }
        
        function drawDivergentPlot() {
            const canvas = document.getElementById('divergent-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 350;
            
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            const testLimit = parseFloat(document.getElementById('test-limit')?.value || 0);
            const epsilon = parseFloat(document.getElementById('div-epsilon')?.value || 0.5);
            const maxTerms = 50;
            
            document.getElementById('test-limit-value').textContent = testLimit.toFixed(1);
            document.getElementById('div-epsilon-value').textContent = epsilon.toFixed(3);
            
            // Calculate value range
            let minValue = Infinity, maxValue = -Infinity;
            for (let n = 1; n <= maxTerms; n++) {
                const value = evaluateSequence(divergentSequence, n);
                if (!isNaN(value) && isFinite(value)) {
                    minValue = Math.min(minValue, value);
                    maxValue = Math.max(maxValue, value);
                }
            }
            
            minValue = Math.min(minValue, testLimit - epsilon);
            maxValue = Math.max(maxValue, testLimit + epsilon);
            
            const range = maxValue - minValue;
            const padding = range * 0.1 || 0.5;
            minValue -= padding;
            maxValue += padding;
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(30, height - 30);
            ctx.lineTo(width - 10, height - 30);
            ctx.moveTo(30, height - 30);
            ctx.lineTo(30, 10);
            ctx.stroke();
            
            // Draw proposed limit and epsilon band
            const limitY = height - 30 - ((testLimit - minValue) / (maxValue - minValue)) * (height - 60);
            
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(30, limitY);
            ctx.lineTo(width - 10, limitY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const epsilonPixels = (epsilon / (maxValue - minValue)) * (height - 60);
            ctx.fillStyle = 'rgba(245, 158, 11, 0.1)';
            ctx.fillRect(30, limitY - epsilonPixels, width - 40, 2 * epsilonPixels);
            
            // Draw points
            let hasEscapingTerms = false;
            for (let n = 1; n <= maxTerms; n++) {
                const x = 30 + (n - 1) * ((width - 40) / maxTerms);
                const value = evaluateSequence(divergentSequence, n);
                
                if (!isNaN(value) && isFinite(value)) {
                    const y = height - 30 - ((value - minValue) / (maxValue - minValue)) * (height - 60);
                    
                    const isEscaping = Math.abs(value - testLimit) >= epsilon;
                    if (isEscaping && n > 10) {  // Check for escaping terms after some initial N
                        hasEscapingTerms = true;
                    }
                    
                    ctx.fillStyle = isEscaping ? '#c62828' : '#10b981';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
            
            // Update floating info
            let seqDisplay = divergentSequence.replace('Math.pow(-1, n)', '(-1)ⁿ')
                                               .replace('Math.sin(n)', 'sin(n)')
                                               .replace('Math.log(n)', 'ln(n)');
            document.getElementById('div-seq').textContent = seqDisplay;
            document.getElementById('div-limit').textContent = testLimit.toFixed(1);
            document.getElementById('div-escape').textContent = hasEscapingTerms ? 'Always has escaping terms' : 'Check larger N values';
            
            // Labels
            ctx.fillStyle = '#f59e0b';
            ctx.font = 'bold 11px sans-serif';
            ctx.fillText(`Test L=${testLimit.toFixed(1)}`, width - 80, limitY - 5);
            
            ctx.fillStyle = '#212121';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('n', width - 10, height - 15);
            ctx.textAlign = 'left';
            ctx.fillText('aₙ', 15, 10);
        }
        
        // Animation functions
        function animateSequence() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                event.target.textContent = '▶ Animate';
                return;
            }
            
            event.target.textContent = '⏸ Pause';
            animationFrame = 0;
            
            function animate() {
                animationFrame++;
                if (animationFrame > parseInt(document.getElementById('explorer-terms').value)) {
                    animationFrame = 0;
                }
                
                drawCoordinatePlot();
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function animateDivergence() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                event.target.textContent = '▶ Animate';
                return;
            }
            
            event.target.textContent = '⏸ Pause';
            let testLimitValue = -2;
            
            function animate() {
                testLimitValue += 0.02;
                if (testLimitValue > 2) testLimitValue = -2;
                
                document.getElementById('test-limit').value = testLimitValue;
                drawDivergentPlot();
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        // Preset handlers
        document.querySelectorAll('#convergent-mode .preset-pill').forEach(pill => {
            pill.addEventListener('click', function() {
                document.querySelectorAll('#convergent-mode .preset-pill').forEach(p => p.classList.remove('active'));
                this.classList.add('active');
                
                currentSequence = this.dataset.seq;
                currentLimit = parseFloat(this.dataset.limit);
                
                initConvergentCanvases();
            });
        });
        
        document.querySelectorAll('#divergent-mode .preset-pill').forEach(pill => {
            pill.addEventListener('click', function() {
                document.querySelectorAll('#divergent-mode .preset-pill').forEach(p => p.classList.remove('active'));
                this.classList.add('active');
                
                divergentSequence = this.dataset.seq;
                
                initDivergentCanvas();
            });
        });
        
        // Challenge functions
        function loadChallenge(mode) {
            challengeMode = mode;
            attempts = 0;
            
            const feedbackEl = document.getElementById('feedback');
            if (feedbackEl) {
                feedbackEl.classList.remove('show');
            }
            
            const standardEl = document.getElementById('standard-challenge');
            const proofEl = document.getElementById('proof-challenge');
            
            if (mode === 'proof') {
                if (standardEl) standardEl.style.display = 'none';
                if (proofEl) proofEl.style.display = 'block';
                
                const proofSet = challenges.proof;
                currentChallenge = proofSet[Math.floor(Math.random() * proofSet.length)];
                
                const questionDiv = document.getElementById('challenge-question');
                if (questionDiv) {
                    if (currentChallenge.type === 'convergence') {
                        questionDiv.innerHTML = `
                            <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Proof by Cards: Convergence</h4>
                            <p>Prove that the sequence:</p>
                            <div class="math-display" id="challenge-seq"></div>
                            <p>converges to ${currentChallenge.limit}</p>
                        `;
                    } else {
                        questionDiv.innerHTML = `
                            <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Proof by Cards: Divergence</h4>
                            <p>Prove that the sequence:</p>
                            <div class="math-display" id="challenge-seq"></div>
                            <p>diverges</p>
                        `;
                    }
                }
                
                setupScrambleCards();
            } else {
                if (standardEl) standardEl.style.display = 'block';
                if (proofEl) proofEl.style.display = 'none';
                
                const answerInput = document.getElementById('challenge-answer');
                if (answerInput) {
                    answerInput.value = '';
                    answerInput.disabled = false;
                }
                
                const challengeSet = challenges[mode];
                currentChallenge = challengeSet[Math.floor(Math.random() * challengeSet.length)];
                
                updateChallengeDisplay();
            }
            
            updateChallengeSequence();
        }
        
        function updateChallengeDisplay() {
            const questionDiv = document.getElementById('challenge-question');
            if (!questionDiv) return;
            
            if (challengeMode === 'detective') {
                questionDiv.innerHTML = `
                    <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Question: Convergence Detective</h4>
                    <p>Consider the sequence:</p>
                    <div class="math-display" id="challenge-seq"></div>
                    <p>Does this sequence converge? If yes, what is the limit?</p>
                `;
            } else if (challengeMode === 'epsilon') {
                questionDiv.innerHTML = `
                    <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Question: Epsilon-N Mastery</h4>
                    <p>For the sequence:</p>
                    <div class="math-display" id="challenge-seq"></div>
                    <p>Find the minimum N such that |aₙ - ${currentChallenge.limit}| < ${currentChallenge.epsilon} for all n ≥ N</p>
                `;
            }
        }
        
        function updateChallengeSequence() {
            if (currentChallenge && document.getElementById('challenge-seq')) {
                katex.render(`a_n = ${currentChallenge.seq}`, 
                    document.getElementById('challenge-seq'), {displayMode: true});
            }
        }
        
        // Scramble cards functionality
        function setupScrambleCards() {
            const container = document.getElementById('scramble-cards');
            if (!container) return;
            
            container.innerHTML = '';
            
            const steps = [...currentChallenge.steps];
            for (let i = steps.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [steps[i], steps[j]] = [steps[j], steps[i]];
            }
            
            steps.forEach((step, index) => {
                const card = document.createElement('div');
                card.className = 'scramble-card';
                card.draggable = true;
                card.dataset.originalIndex = currentChallenge.steps.indexOf(step);
                card.innerHTML = step;
                
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragover', handleDragOver);
                card.addEventListener('drop', handleDrop);
                card.addEventListener('dragend', handleDragEnd);
                
                container.appendChild(card);
            });
        }
        
        function handleDragStart(e) {
            draggedCard = this;
            this.classList.add('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            const afterElement = getDragAfterElement(e.currentTarget.parentNode, e.clientY);
            const container = e.currentTarget.parentNode;
            
            if (afterElement == null) {
                container.appendChild(draggedCard);
            } else {
                container.insertBefore(draggedCard, afterElement);
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
        }
        
        function handleDragEnd(e) {
            this.classList.remove('dragging');
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.scramble-card:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
        
        function checkCardOrder() {
            const cards = document.querySelectorAll('.scramble-card');
            let correct = true;
            
            cards.forEach((card, index) => {
                if (parseInt(card.dataset.originalIndex) !== index) {
                    correct = false;
                }
            });
            
            const feedback = document.getElementById('feedback');
            if (!feedback) return;
            
            feedback.classList.remove('success', 'error', 'hint');
            
            if (correct) {
                feedback.classList.add('success');
                feedback.innerHTML = '<strong>Perfect!</strong> You\'ve arranged the proof correctly! Moving to next problem...';
                
                setTimeout(() => {
                    loadChallenge('proof');
                }, 3000);
            } else {
                feedback.classList.add('error');
                attempts++;
                feedback.innerHTML = attempts < 3 ? 
                    '<strong>Not quite right.</strong> Think about the logical flow of the proof.' :
                    '<strong>Hint:</strong> Start with what we need to prove, then work through the algebra systematically.';
            }
            
            feedback.classList.add('show');
        }
        
        function shuffleCards() {
            setupScrambleCards();
            const feedback = document.getElementById('feedback');
            if (feedback) {
                feedback.classList.remove('show');
            }
            attempts = 0;
        }
        
        function showCorrectOrder() {
            const container = document.getElementById('scramble-cards');
            if (!container) return;
            
            const cards = [...container.querySelectorAll('.scramble-card')];
            
            cards.sort((a, b) => {
                return parseInt(a.dataset.originalIndex) - parseInt(b.dataset.originalIndex);
            });
            
            container.innerHTML = '';
            cards.forEach(card => container.appendChild(card));
            
            const feedback = document.getElementById('feedback');
            if (feedback) {
                feedback.classList.remove('success', 'error');
                feedback.classList.add('hint');
                feedback.innerHTML = '<strong>Solution shown.</strong> Study the logical flow carefully!';
                feedback.classList.add('show');
            }
        }
        
        function quickCheck() {
            const answer = document.getElementById('challenge-answer').value.toLowerCase().trim()
                .replace(/\s+/g, ' ')  // normalize spaces
                .replace(/→/g, '->')   // normalize arrows
                .replace(/converge /g, 'converges '); // normalize verb forms
            
            const feedback = document.getElementById('feedback');
            if (!feedback) return;
            
            attempts++;
            
            let isCorrect = false;
            
            if (challengeMode === 'detective') {
                // Check against all acceptable variations
                isCorrect = currentChallenge.acceptableAnswers.some(acceptable => 
                    answer === acceptable.toLowerCase() || 
                    answer === acceptable.toLowerCase().replace(/\s+/g, '')
                );
            } else if (challengeMode === 'epsilon') {
                const numAnswer = parseInt(answer);
                isCorrect = currentChallenge.acceptableAnswers.includes(numAnswer) || 
                           currentChallenge.acceptableAnswers.includes(answer);
            }
            
            feedback.classList.remove('success', 'hint', 'error');
            
            if (isCorrect) {
                feedback.classList.add('success');
                feedback.innerHTML = `<strong>Excellent!</strong> You got it right! The answer is indeed ${currentChallenge.answer}.`;
                document.getElementById('challenge-answer').disabled = true;
                
                setTimeout(() => {
                    loadChallenge(challengeMode);
                }, 3000);
            } else {
                feedback.classList.add('error');
                if (attempts < 3) {
                    feedback.innerHTML = `<strong>Not quite.</strong> Try again! Remember to check your answer format.`;
                } else {
                    feedback.innerHTML = `<strong>Hint:</strong> ${currentChallenge.hint}`;
                }
            }
            
            feedback.classList.add('show');
        }
        
        function getHint() {
            const feedback = document.getElementById('feedback');
            if (!feedback) return;
            
            feedback.classList.remove('success', 'error');
            feedback.classList.add('hint', 'show');
            feedback.innerHTML = `<strong>Hint:</strong> ${currentChallenge.hint}`;
        }
        
        // AI Challenge function
        async function challengeAI() {
            const answer = document.getElementById('challenge-answer').value.trim();
            const feedback = document.getElementById('feedback');
            if (!feedback) return;
            
            if (!answer) {
                feedback.classList.add('error', 'show');
                feedback.innerHTML = '<strong>Please enter an answer first!</strong>';
                return;
            }
            
            feedback.classList.remove('success', 'error');
            feedback.classList.add('hint', 'show');
            feedback.innerHTML = '<strong>Analyzing your answer...</strong>';
            
            try {
                const prompt = `You are a supportive high school math teacher evaluating a student's answer about sequence convergence.

The sequence is: ${currentChallenge.seq}
The correct answer is: ${currentChallenge.answer}
The student's answer is: "${answer}"

Evaluate the student's response:
- If correct or essentially correct (even with minor formatting differences): Confirm with specific praise about their understanding
- If partially correct: Acknowledge what's right, give ONE specific hint about what's missing
- If incorrect: Give a conceptual hint that guides them toward the right thinking without revealing the answer

Keep your response to 2-3 sentences. Use $ for inline LaTeX and $$ for display LaTeX when needed.
Be encouraging and reference their specific answer.`;

                const response = await callAI(prompt);
                
                feedback.classList.remove('hint');
                feedback.classList.add('show');
                
                // Parse the response and render any LaTeX
                const processedResponse = response.replace(/\$\$(.*?)\$\$/g, (match, p1) => {
                    const span = document.createElement('span');
                    katex.render(p1, span, {displayMode: true});
                    return span.outerHTML;
                }).replace(/\$(.*?)\$/g, (match, p1) => {
                    const span = document.createElement('span');
                    katex.render(p1, span, {displayMode: false});
                    return span.outerHTML;
                });
                
                feedback.innerHTML = `<strong>AI Feedback:</strong> ${processedResponse}`;
                
            } catch (error) {
                feedback.classList.add('error');
                feedback.innerHTML = '<strong>AI unavailable.</strong> Try using Quick Check or Get Hint instead.';
            }
        }
        
        // AI API call function (Mathswell standard)
        async function callAI(prompt, maxRetries = 2) {
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    if (attempt > 0) {
                        await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                    }
                    
                    const response = await fetch('/api/gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            contents: [{ role: "user", parts: [{ text: prompt }] }] 
                        })
                    });
                    
                    if (!response.ok) throw new Error(`API error: ${response.status}`);
                    
                    const data = await response.json();
                    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (!text) throw new Error('Empty response from AI');
                    
                    return text;
                    
                } catch (error) {
                    if (attempt === maxRetries) throw error;
                }
            }
        }
        
        // Event listeners
        document.getElementById('demo-epsilon')?.addEventListener('input', initDemoCanvas);
        document.getElementById('demo-terms')?.addEventListener('input', initDemoCanvas);
        document.getElementById('explorer-epsilon')?.addEventListener('input', initConvergentCanvases);
        document.getElementById('explorer-terms')?.addEventListener('input', initConvergentCanvases);
        document.getElementById('test-limit')?.addEventListener('input', initDivergentCanvas);
        document.getElementById('div-epsilon')?.addEventListener('input', initDivergentCanvas);
        
        // Initialize on load
        window.addEventListener('load', () => {
            renderMath();
            setTimeout(initDemoCanvas, 100);
            
            // Only load challenge if we're on the challenge tab or if the elements exist
            const challengeEl = document.getElementById('challenge');
            if (challengeEl) {
                loadChallenge('detective');
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const activeTab = document.querySelector('.tab-content.active').id;
            if (activeTab === 'intro') {
                initDemoCanvas();
            } else if (activeTab === 'explorer') {
                if (currentMode === 'convergent') {
                    initConvergentCanvases();
                } else {
                    initDivergentCanvas();
                }
            }
        });
    </script>
</body>
</html>
